<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <link href="./css/index.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=IBM+Plex+Mono:300,400,700" rel="stylesheet">
    <!-- link href="https://fonts.googleapis.com/css?family=Merriweather|Poly" rel="stylesheet" -->
  </head>

  <body>
    <aside>
      <h3>01 programming</h3>

        <a class="link" href="#post-01-bet-on-the-web---and-web-components">
          01 bet on the web - and web components
        </a>
        <br>
      


        <a class="link" href="#post-02-what-are-javascript-then-ables">
          02 what are javascript then-ables
        </a>
        <br>
      <h3>02 computer science</h3>

        <a class="link" href="#post-01-illustrated-lamport-timestamp">
          01 illustrated lamport timestamp
        </a>
        <br>
      <h3>03 other</h3>

        <a class="link" href="#post-01-code">
          01 code
        </a>
        <br>
      


        <a class="link" href="#post-02-curriculum-vitae">
          02 curriculum vitae
        </a>
        <br>
      
    </aside>

    <div id="posts" role="main">
      <section class="post" id="post-01-bet-on-the-web---and-web-components">
  <h1 id="bet-on-the-web-and-web-components">bet on the web - and web components</h1>
<h3 id="2018-08-02">2018-08-02</h3>
<p>I don&#39;t use frameworks, so React appeals to me. I like how it organizes ideas.
I like its top-down, one-way flow of data. But I also think some of its
usefulness is debatable. It has a big island of tooling that&#39;s going in a
very different direction than the rest of the web. Like Coffeescript or jQuery,
in 5 years it will probably inspire standards bodies with its best features.</p>
<p>I also like Web Components, they&#39;re great because they offer true, native
encapsulation &nbsp;&mdash;&nbsp; no hacks. They are mostly the result of
consensus among the web&#39;s working groups. They&#39;re pretty awkward, like most of
the web&#39;s native APIs &nbsp;&mdash;&nbsp; but a foundation to build on.</p>
<p><img src="https://raw.githubusercontent.com/hxoht/tonic/addimage/readme-tonic.png" alt="img"></p>
<p>I&#39;d like to introduce Tonic. It&#39;s about 125 lines of code. It&#39;s much less
opinionated than React. It shares some of the same goals; though its main goal
is to provide the <em>minimum</em> of what is needed to organize code, the flow of
data and create component based architecture. Most importantly, it&#39;s built on
the platform of the future, the web.</p>
<p>You can find the project <a href="https://github.com/hxoht/tonic/">here</a> on Github.</p>

  <div class="up">
    <svg>
      <use xlink:href="/images/sprite.svg#up">
    </svg>
  </div>
</section>
,<section class="post" id="post-02-what-are-javascript-then-ables">
  <h1 id="what-are-javascript-then-ables">What are javascript then-ables</h1>
<p><em>async / await</em> improves program flow and reduces the number of callbacks in
your code. The <code>await</code> keyword can be used to pause the current code path and
wait for an async function to return a value without blocking the <a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/">event loop</a>.</p>
<pre><code class="lang-js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'started'</span>)
  <span class="hljs-keyword">await</span> sleep(<span class="hljs-number">100</span>)
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'finished'</span>)
}

main()
</code></pre>
<p>An implementation for the <code>sleep</code> function might look like this...</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> sleep = <span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> setTimeout(r, n))
</code></pre>
<p>However, as this example demonstrates, the code in the promise starts executing
immediately. Promises are eager (as opposed to being <em>lazy</em>), and sometimes we
want them to be lazy, for example, to reusable tasks. <a href="https://staltz.com/promises-are-not-neutral-enough.html">Here</a> is a detailed
explaination of why an eager promise may not be what you want.</p>
<p>A then-able is lazy. It has no constructor. It&#39;s any function, object or class
that implements a <code>then</code> method.</p>
<h3 id="await-able-classes">Await-able Classes</h3>
<p>To create an async class, implement a <code>then</code> method on it!</p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>{
  then (resolve, reject) {
    resolve(<span class="hljs-number">42</span>)
  }
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> answer = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> Foo()
  <span class="hljs-comment">// answer === 42</span>
}
main()
</code></pre>
<h3 id="await-able-objects">Await-able Objects</h3>
<p>You can do the same thing with an object. You can name the callback
functions whatever you want. Also, you aren&#39;t required to use or care
about the <code>rejection</code> callback.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> Foo = {
  then (resolve) {
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(<span class="hljs-number">42</span>), <span class="hljs-number">1024</span>)
  }
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> answer = <span class="hljs-keyword">await</span> Foo
  <span class="hljs-comment">// answer === 42</span>
}
main()
</code></pre>
<h3 id="await-able-object-factories">Await-able object factories</h3>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> Foo = <span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> ({
  then (resolve) {
    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(num), <span class="hljs-number">1024</span>)
  }
})

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> answer = <span class="hljs-keyword">await</span> Foo(<span class="hljs-number">42</span>)
}
main()
</code></pre>
<h3 id="async-then-ables">Async then-ables</h3>
<p>Object and class methods can use the async keyword, just like functions.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> Foo = {
  <span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-title">then</span> (<span class="hljs-params">resolve</span>) </span>{
    resolve(<span class="hljs-keyword">await</span> request(<span class="hljs-string">'https://foo.com'</span>))
  }
}
</code></pre>
<p>Destructuring assignments provide a way to return multiple values...</p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>{
  then (resolve) {
    request(<span class="hljs-string">'https://foo.com'</span>, (err, res) =&gt; resolve({ err, res }))
  }
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> { err, res } = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> Foo

  <span class="hljs-comment">// More than one err? Const is block-scoped!</span>
  {
    <span class="hljs-keyword">const</span> { err, res } = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> Foo
  }

  <span class="hljs-comment">// Destructured values can also be aliased.</span>
  <span class="hljs-keyword">const</span> { <span class="hljs-attr">err</span>: namedError, <span class="hljs-attr">res</span>: namedResponse } = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> Foo
}
main()
</code></pre>

  <div class="up">
    <svg>
      <use xlink:href="/images/sprite.svg#up">
    </svg>
  </div>
</section>
<section class="post" id="post-01-illustrated-lamport-timestamp">
  <h1 id="illustrated-lamport-timestamp">illustrated lamport timestamp</h1>
<p>A <em>Lamport Timestamp</em> can be used to determine the order of events in a
distributed system. They are a useful primative when you&#39;re building
peer-to-peer applications and you want to thread together datasets from
different sources.</p>
<h3 id="clocks-vs-logical-clocks">Clocks vs. Logical Clocks</h3>
<p>Why don&#39;t we use regular time stamps? Most clocks count time at different rates
and experience failures that require resynchronization. This means they are
reliably unreliable for determining ordering of events.</p>
<p>Lamport Timestamps use a <em>Logical Clock</em> to keep track of the order of events
on each node. A logical clock is not a clock that keeps track of the time, it&#39;s
a <a href="https://en.wikipedia.org/wiki/Monotonic_function">monotonically increasing</a> counter. So, when a node in a network receives a message, it
re-synchronizes its counter (its clock) with the node that sent the message.</p>
<h3 id="example">Example</h3>
<p>Node <code>A</code> increments its clock before each event that hapens. An event is
something meaningful, like when it creates some data. When node <code>A</code>
eventually sends its payload over the network, it will include the current
value of its clock.</p>
<pre><code class="lang-js"><span class="hljs-keyword">let</span> clock = <span class="hljs-number">0</span>

<span class="hljs-comment">//</span>
<span class="hljs-comment">// A thread-safe, monotonically increasing function.</span>
<span class="hljs-comment">//</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createTimeStamp</span> (<span class="hljs-params"></span>) </span>{
  clock += <span class="hljs-number">1</span>
  <span class="hljs-keyword">return</span> clock 
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doSomething</span> (<span class="hljs-params">data</span>) </span>{
  <span class="hljs-comment">//</span>
  <span class="hljs-comment">// Do something with some data.</span>
  <span class="hljs-comment">//</span>
  <span class="hljs-keyword">return</span> {
    data,
    <span class="hljs-attr">clock</span>: createTimeStamp()
  }
}

<span class="hljs-comment">//</span>
<span class="hljs-comment">// Eventually send the data to the network.</span>
<span class="hljs-comment">//</span>
sendToNetworkQueue(doSomething({ ... }))
</code></pre>
<p>When node <code>B</code> receives a message from node <code>A</code>, it will decide how to set
its own clock. If the clock value in the message is greater than its own
value, it will use the value in the message. Otherwise it will use its own
value. In either case, it will also increment its own clock by <code>1</code>.</p>
<pre><code class="lang-js">let clock = <span class="hljs-number">0</span>

<span class="hljs-comment">//</span>
<span class="hljs-comment">// Eventually receive some data from the network.</span>
<span class="hljs-comment">//</span>
receiveFromNetworkQueue (<span class="hljs-class"><span class="hljs-keyword">message</span>) {</span>
  clock = Math.max(<span class="hljs-class"><span class="hljs-keyword">message</span>.<span class="hljs-title">clock</span>, clock) + 1
}</span>
</code></pre>
<p>Here we semi-randomly fail to always tell the other node about the event that
happened, illustrating what happens when a node is eventually synchronized.</p>
<div id="lamport-timestamp">
  <div id="timeline-node-a" class="timeline"></div>
  <div id="timeline-node-b" class="timeline"></div>
</div>

<div id="node-event-links">
  <div data-name="a">Fire event on node A</div>
  <div data-name="b">Fire event on node B</div>
</div>

<p>This may not be the correct primative for all your use cases. For example,
Lamport Timestamps don&#39;t express causality, meaning, the <em>reason</em> why one
event happened before another isn&#39;t in scope of this soluton, but that is
something that can be achieved using a <a href="https://en.wikipedia.org/wiki/Vector_clock">Vector Clock</a>.</p>
<script>

  function ready () {
    const timelineA = document.getElementById('timeline-node-a')
    timelineA.dataset.name = "node a"

    const timelineB = document.getElementById('timeline-node-b')
    timelineB.dataset.name = "node b"

    let clockA = 0
    let clockB = 0

    function reset () {
      clockA = 0
      clockB = 0
      while(timelineA.firstChild) timelineA.firstChild.remove()
      while(timelineB.firstChild) timelineB.firstChild.remove()
    }

    let timer = null

    function createEvent (timeline, clock) {
      if (clock === 25) {
        clock = 1
        reset()
      }

      [...timeline.querySelectorAll('.clock')].map(el => {
        el.classList.remove('show')
      })

      const event = document.createElement('div')
      event.classList.add('event')

      const tooltip = document.createElement('div')
      tooltip.className = 'clock show'
      tooltip.textContent = `Clock = ${clock}`

      event.style.left = `${clock * 25}px`
      event.appendChild(tooltip)

      timeline.appendChild(event)
      timer = setTimeout(() => {
        tooltip.classList.remove('show')
      }, 2048)
    }

    function nodeA (n) {
      if (n > 0) {
        clockA = Math.max(n, clockA) + 1
      } else {
        clockA++

        if (Math.floor(Math.random() * 100) % 2 === 0) {
          nodeB(clockA)
        }
      }
      createEvent(timelineA, clockA)
    }

    function nodeB (n) {
      if (n > 0) {
        clockB = Math.max(n, clockB) + 1
      } else {
        clockB++

        if (Math.floor(Math.random() * 100) % 2 === 0) {
          nodeA(clockB)
        }
      }

      createEvent(timelineB, clockB)
    }

    const links = document.getElementById('node-event-links')

    links.addEventListener('click', ({ target }) => {
      switch (target.dataset.name) {
        case 'a':
          nodeA()
          break;
        case 'b':
          nodeB()
          break;
      }
    })
  }

  document.addEventListener('DOMContentLoaded', ready)

</script>


  <div class="up">
    <svg>
      <use xlink:href="/images/sprite.svg#up">
    </svg>
  </div>
</section>
<section class="post" id="post-01-code">
  <h1 id="code">CODE</h1>
<h2 id="github">GITHUB</h2>
<p><a href="https://github.com/hxoht">https://github.com/hxoht</a></p>
<h2 id="public-key">PUBLIC KEY</h2>
<pre>
<textarea spellcheck="false" disabled resize="false">
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQC+akORhccxOBxXHKTb3p1CEIUg+/rFxcckARqZ2F3qBOpYzUEPII7aGWwnexgnTLtuaLb0pujFcawne+z/c8mFFnrxc99gG76cRKUsDLcdNXEa3kCBrQG3dXf+J8mIbzIFaabreP0fQAqwI9hbM/SUFwrPbCbfTcZcpn4pgbCSDxLXC0qb1Zh9UkcV4RP3A9r8sy92PrmtUmJTXWdZE043eAXpgerhRkHC38BL2JsmVf6/nOonlHfJiue7nowUaA7bvaA8GGlJRFaNhoFfTYIkMv9pOGaNpTtdK+UpOOO1U8MBlWPI86VOY/0VQj1pZOc8r0hqd3o+ALg9TKtkZKfSgZs4JQRRul4Zvmmc/mJfVJ9x/2rLdSnR19swSkJkyXZh/Q2/4u/Zp1J0+JuWMugLQzkJIfYMEeOm6Z3dk8O3Br1aMA+HPiDLgJjeV5SZm6is+DXdPA9s6CyQ2F3oazD1g1k/34W2p3+dnpAQU6W/73sxzyteUo7FNkGw7uGi7a5Gowmn6VtcoBDyY8QUUduUoCx747DZ61UTFPtesDc2HvPoemH8PYXjduA93CGtdh8ir7HsO9J0uzhC1FqrGskRpjNVZWWo6jERYamnbzYUs4VVy7qxcBy7skAe9JtGq3+MMjt6mvt9doxOAazUiAd/I9YWBCkWk/gwvy1qHa7R/w== hi@hx.ht
</textarea>
</pre>

  <div class="up">
    <svg>
      <use xlink:href="/images/sprite.svg#up">
    </svg>
  </div>
</section>
,<section class="post" id="post-02-curriculum-vitae">
  <h1 id="curriculum-vitae">Curriculum Vitae</h1>
<div class="avatar"></div>

<h2 id="personal">Personal</h2>
<p>Name: Paolo Fragomeni, Software Engineer</p>
<p>Nationality: American</p>
<p>Date of Birth: May 27th, 1979</p>
<p>Languages: English (Fluent), German (Elementary), Dutch (Elementary)</p>
<h2 id="contact">Contact</h2>
<p>Email: <a href="mailto:hello@hx.ht">hello@hx.ht</a></p>
<p>Web: <a href="https://hx.ht">https://hx.ht</a></p>
<p>Twitter: <a href="https://twitter.com/hxoht">https://twitter.com/hxoht</a></p>
<p>Github: <a href="https://github.com/hxoht">https://github.com/hxoht</a></p>
<h2 id="summary">Summary</h2>
<p>I Left MIT in 2010 to co-found Nodejitsu (a PaaS, since integrated with
GoDaddy). Most recently I founded Voltra Co. (entertainment software) which
joined Conductor Lab. In addition to being a technical founder, CTO and engineer
I have worked in the infosec space.</p>
<h2 id="expertise">Expertise</h2>
<p>Computer Science Research. Software Engineering: programming design and
engineering, concurrent and distributed programming, metaprogramming,
functional programming and ECMAScript (Javascript). Key-Value store</p>
<h2 id="experience">Experience</h2>
<h3 id="cto-cofounder-at-voltra-co-">CTO, Cofounder at Voltra Co.</h3>
<p>January 2016 - Augest 2018 (2.5 years)</p>
<p>Voltra Co. was a cloud storage service and set of audio products. Voltra&#39;s
desktop and mobile players sync so you can stream your music from anywhere.
The only ad-free fully hi-res platform. On this project I worked with
Electron, JavaScript, Node.js, C++, CSS3, HTML5, Stylus, Jade, Webpack,
React, React-Native, and Amazon Web Services. Voltra joined Conductor Lab
in Augest 2018.</p>
<h3 id="vp-of-engineering-at-now-secure">VP of Engineering at Now Secure</h3>
<p>November 2014 - January 2016 (1 year 3 months)</p>
<p>Built engineering and security research teams. Coordinated engineering and
research teams. Set technical goals, worked hands on on lots of projects.
On this project I worked primarily with C, C++, JavaScript, Node.js, HTML5.</p>
<h3 id="engineer-cto-at-mic">Engineer, CTO at Mic</h3>
<p>January 2014 - November 2014 (11 months)</p>
<p>Hereishow.to joined mic.com where I served as CTO. Built an engineering team
and integrated components of Here Is How into existing products. On this
project I worked with Amazon Web Services, Node.js JavaScript, HTML5, CSS3.</p>
<h3 id="engineer-cto-cofounder-at-here-is-how">Engineer, CTO, Cofounder at Here Is How</h3>
<p>November 2012 - January 2014 (1 year 3 months)</p>
<p>A CMS for technical writing, a web based interface similar to Medium.com.
This project was acqui-hired by mic.com On this project I worked with Docker,
JavaScript, Node.js, Websockets, C, C++, HTML5, CSS3.</p>
<h3 id="engineer-cto-cofounder-at-nodejitsu">Engineer, CTO, Cofounder at Nodejitsu</h3>
<p>September 2010 - December 2012 (2 years 4 months)</p>
<p>Co-Founder, Chief Technology Officer. Lots of R&amp;D. Conceptualized and
implemented products that simplify and manage application deployments
for the node.js platform.</p>

  <div class="up">
    <svg>
      <use xlink:href="/images/sprite.svg#up">
    </svg>
  </div>
</section>

    </div>

    <script src="./bundle.js"></script>

  </body>
</html>
