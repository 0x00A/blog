<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <link href="./css/index.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Merriweather|Poly" rel="stylesheet">
  </head>

  <body>
    <header>
      <div class="intro">
        <p>Hello, My Name is</p>
        <h1>Paolo Fragomeni</h1>
        <p class="first-line">I write software and create products. This is a journal of brief technical notes and random ideas.</p>
        <h2><a href="https://github.com/0x00a/">Code</a>, <a href="https://twitter.com/0x00A">Tweets</a> &amp; <a href="/cv.html">Curriculum Vitae</a></h2>
      </div>
    </header>

    <div id="blog" role="main">

      <section id="posts" name="blog">
        
  <div class="post" id="Swift-for-Javascripters:-Lambda-Capture">
    <a class="link" href="#Swift-for-Javascripters:-Lambda-Capture">
      <div class="labels"></div>
      <h1 class="title">Swift for Javascripters: Lambda Capture</h1>
    </a>
    <div class="body">
      <p>Sometimes you want to capture the state of a variable in a function&#39;s
closure for later use. In JavaScript you could do that like this...</p>
<pre><code class="lang-js">let <span class="hljs-selector-tag">a</span> = <span class="hljs-number">0</span>
let <span class="hljs-selector-tag">b</span> = <span class="hljs-number">0</span>

const closure = (<span class="hljs-selector-tag">a</span> =&gt; () =&gt; {
  console.log(<span class="hljs-selector-tag">a</span>, b)
})(a)

<span class="hljs-selector-tag">a</span> = <span class="hljs-number">10</span>
<span class="hljs-selector-tag">b</span> = <span class="hljs-number">10</span>
<span class="hljs-function"><span class="hljs-title">closure</span><span class="hljs-params">()</span></span>
</code></pre>
<pre><code><span class="hljs-symbol">0 </span><span class="hljs-number">10</span>
</code></pre><p>In Swift, a closure (or lambda function) looks like this (and here&#39;s a nice troll; Swift&#39;s <code>let</code> is JavaScript&#39;s <code>const</code> and Swift&#39;s <code>var</code> is JavaScript&#39;s <code>let</code>. And Swift has no equivalent of JavaScript&#39;s <code>var</code>)...</p>
<pre><code class="lang-swift">let closure = {
  print(<span class="hljs-string">"hello"</span>)
}

<span class="hljs-function"><span class="hljs-title">closure</span><span class="hljs-params">()</span></span>
</code></pre>
<pre><code>hello
</code></pre><p>Simple! But it has more features. You can pass it a list of parameters. You
can optionally specify a return type. And if your lambda function contains a
single expression, it will implicitly return that value, just like JavaScript.</p>
<pre><code class="lang-swift">{ <span class="hljs-function"><span class="hljs-params">(parameters)</span> -&gt;</span> returntype <span class="hljs-keyword">in</span>
    statements
}
</code></pre>
<p>Here&#39;s a more concrete example of a function that takes two strings and joins
them. In many cases, Swift can figure out the return type for you. But in this
case we specify the return type to avoid ambiguity with the <code>+</code> operator.</p>
<pre><code class="lang-swift">let fn = { (<span class="hljs-selector-tag">a</span>, b) -&gt; String <span class="hljs-keyword">in</span>
  <span class="hljs-selector-tag">a</span> + <span class="hljs-selector-tag">b</span>
}

<span class="hljs-function"><span class="hljs-title">fn</span><span class="hljs-params">(<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>)</span></span>
</code></pre>
<pre><code><span class="hljs-string">"helloworld"</span>
</code></pre><p>If we want, we can also tell Swift what kinds of parameters the lambda
function will receive!</p>
<pre><code class="lang-swift">let fn = { (<span class="hljs-selector-tag">a</span>: Int, <span class="hljs-selector-tag">b</span>: Int) -&gt; Int <span class="hljs-keyword">in</span>
  <span class="hljs-selector-tag">a</span> + <span class="hljs-selector-tag">b</span>
}

<span class="hljs-function"><span class="hljs-title">fn</span><span class="hljs-params">(<span class="hljs-number">100</span>, <span class="hljs-number">1</span>)</span></span>
</code></pre>
<pre><code>101
</code></pre><p>You can also pass what is called a <code>capture list</code>. A capture list can
contain multiple values separated by commas. It&#39;s also not limited to
values, it can contain expressions.</p>
<pre><code class="lang-swift">{ [captures] (<span class="hljs-name">parameters</span>) -&gt; returntype in
    statements
}
</code></pre>
<p>And finally, here is an example of how a variable in your program might
change, but the lambda can capture its value so it is retained for later
use.</p>
<pre><code class="lang-swift"><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> = <span class="hljs-number">0</span>
<span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">b</span> = <span class="hljs-number">0</span>

let closure = { [a] <span class="hljs-keyword">in</span>
  print(<span class="hljs-selector-tag">a</span>, b)
}

<span class="hljs-selector-tag">a</span> = <span class="hljs-number">10</span>
<span class="hljs-selector-tag">b</span> = <span class="hljs-number">10</span>
<span class="hljs-function"><span class="hljs-title">closure</span><span class="hljs-params">()</span></span>
</code></pre>
<pre><code><span class="hljs-symbol">0 </span><span class="hljs-number">10</span>
</code></pre>
    </div>
  </div>


  <div class="post" id="Swift-for-Javascripters:-Super-powered-If-statements-(Part-1)">
    <a class="link" href="#Swift-for-Javascripters:-Super-powered-If-statements-(Part-1)">
      <div class="labels"><span>JavaScript</span> <span>Programming</span> <span>Swift</span></div>
      <h1 class="title">Swift for Javascripters: Super powered If statements (Part 1)</h1>
    </a>
    <div class="body">
      <p>First, a little bit about nothing... In JavaScript, you have the primitive type: <code>undefined</code> which indicates that a variable has never been initialized (or simply does not exist). You also have an entirely different type: <code>null</code>, which can be used to communicate intent: a value has been intentionally set to nothing.</p>
<p>To handle the absence of a value, Swift has the type <code>Optional</code>. It either contains a value and has a specific type or it will be <code>nil</code>.</p>
<p>Swift also has a feature called <code>optional binding</code>. This is like an <code>if</code> statement, but with more features. As with normal <code>if</code> statements, you can check that boolean expressions evaluate to true. But this syntax will also allow you to declare variables (and/or constants) that must result in non-<code>nil</code> values before the statement will execute the associated code block. If the block is executed, the variables that are declared can be used, but only inside that block.</p>
<p>Consider a hypothetical function that takes an array of numbers and returns their <code>min</code> and <code>max</code> values...</p>
<pre><code class="lang-swift"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> bounds = minMax(array: [<span class="hljs-number">8</span>, -<span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">109</span>, <span class="hljs-number">3</span>, <span class="hljs-number">71</span>]) {
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"min is <span class="hljs-subst">\(bounds.<span class="hljs-built_in">min</span>)</span> and max is <span class="hljs-subst">\(bounds.<span class="hljs-built_in">max</span>)</span>"</span>)
}
</code></pre>
<p>The JS equivalent…</p>
<pre><code class="lang-js">{
  const bounds = mixMax([<span class="hljs-number">8</span>, <span class="hljs-number">-6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">109</span>, <span class="hljs-number">3</span>, <span class="hljs-number">71</span>])

  if (<span class="hljs-name">bounds</span>) {
    console.log(`min is ${bounds.min} and max is ${bounds.max}`)
  }
}
</code></pre>
<p>It is also possible to check multiple values and/or booleans at once...</p>
<pre><code class="lang-swift"><span class="hljs-keyword">if</span> let <span class="hljs-selector-tag">a</span> = Int(<span class="hljs-string">"1"</span>), let <span class="hljs-selector-tag">b</span> = Int(<span class="hljs-string">"1"</span>), <span class="hljs-selector-tag">a</span> == <span class="hljs-selector-tag">b</span> {
  print(<span class="hljs-string">"a: \(a) is equal to b: \(b)"</span>)
}
</code></pre>
<p>The JS equivalent…</p>
<pre><code class="lang-js">{
  <span class="hljs-keyword">const</span> a = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">"1"</span>, <span class="hljs-number">10</span>)

  <span class="hljs-keyword">if</span> (a) { <span class="hljs-comment">// ...don't evaluate `b` if `a` is not valid.</span>
   <span class="hljs-keyword">const</span> b = <span class="hljs-built_in">parseInt</span>(<span class="hljs-string">"1"</span>, <span class="hljs-number">10</span>)

   <span class="hljs-keyword">if</span> (b &amp;&amp; a === b) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`a: <span class="hljs-subst">${a}</span> is equal to b: <span class="hljs-subst">${b}</span>`</span>)
  }
}
</code></pre>

    </div>
  </div>


  <div class="post" id="Async/await-without-Promises">
    <a class="link" href="#Async/await-without-Promises">
      <div class="labels"><span>idea</span> <span>Programming</span></div>
      <h1 class="title">Async/await without Promises</h1>
    </a>
    <div class="body">
      <p>A while ago I posted about using generators and destructuring assignments for flow control. Now that <code>async</code> has landed and its usable everywhere, I almost always use <code>async/await</code>.</p>
<p>I&#39;ve never really liked promises. In many ways, they are just as bad as callbacks but with more moving parts. Luckily, promises aren&#39;t really a requirement for using <code>async/await</code>. In fact, you can bypass the promise constructor entirely. Just create a <code>then-able</code>. A <code>then-able</code> is any function, object or class that implements a <code>then</code> function (or member, respectively). For example...</p>
<h2 id="await-able-classes">Await-able Classes</h2>
<p>To create an async class, just implement a then method on it!</p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>{
  then (success, fail) {
    success(<span class="hljs-number">42</span>)
  }
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> answer = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> Foo
}
main()
</code></pre>
<h2 id="awaitable-objects">Awaitable Objects</h2>
<p>You can just do the same thing with an object.</p>
<pre><code class="lang-js">const Foo = {
  <span class="hljs-keyword">then</span> (<span class="hljs-keyword">done</span>) {
    <span class="hljs-keyword">done</span> (await request(<span class="hljs-string">'https://foo.com'</span>))
  }
}
</code></pre>
<h2 id="await-inside-then-ables">Await inside then-ables</h2>
<p>Object and class methods can use the async keyword, just like functions.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> Foo = {
  <span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-title">then</span> (<span class="hljs-params">done</span>) </span>{
    done(<span class="hljs-keyword">await</span> request(<span class="hljs-string">'https://foo.com'</span>))
  }
}
</code></pre>
<p>And finally here is something really contentious for all you dare devils out there. You can use destructuring assignments to return multiple values, which could be handy when you are doing async things…</p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>{
  then (done) {
    request(<span class="hljs-string">'https://foo.com'</span>, (err, res) =&gt; done([err, res]))
  }
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> [err, res] = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> Foo
}
main()
</code></pre>
<p>And, there is of course more than one way to return more than one value!</p>
<pre><code class="lang-js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>{
  then (done) {
    request(<span class="hljs-string">'https://foo.com'</span>, (err, res) =&gt; done({ err, res }))
  }
}

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> { err, res } = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> Foo
}
main()
</code></pre>
<p>Sure some people might argue that C-style error passing is error-prone. But, bubbling is just as susceptible to mishandling. Choose your poison.</p>

    </div>
  </div>


  <div class="post" id="Data-Modeling-in-Javascript">
    <a class="link" href="#Data-Modeling-in-Javascript">
      <div class="labels"><span>Programming</span></div>
      <h1 class="title">Data Modeling in Javascript</h1>
    </a>
    <div class="body">
      <p><img src="https://cloud.githubusercontent.com/assets/136109/20865895/3bb07ace-ba1e-11e6-9294-75b98219b660.png" alt="image">
Working on <a href="https://voltra.co.">Voltra Co.</a>, I’ve needed to validate a lot of data. I’ve tried some pretty clever solutions for validating and describing data. But after working daily with these libraries, I’ve found that the javascript just gets in the way. Too much syntax, too much boiler plate, etc. 50+ models with 30+ entities can become a nightmare to read and maintain.</p>
<p>Anyway, after much GTD I took a break to put together <a href="http://voltraco.github.io/dml/">DML</a>. DML is a simple language with the goal of making your data models readable and maintainable. The javascript implementation is only a few hundred lines. The documentation is a work in progress at the moment but the syntax looks like this…</p>
<pre><code class="lang-js"><span class="hljs-comment">//</span>
<span class="hljs-comment">// An example data model</span>
<span class="hljs-comment">//</span>

<span class="hljs-built_in">Date</span> created
Number id

<span class="hljs-built_in">String</span> name
  <span class="hljs-keyword">require</span> <span class="hljs-literal">true</span> <span class="hljs-string">"a name is required"</span> <span class="hljs-comment">// this is a comment</span>
  <span class="hljs-literal">gt</span> <span class="hljs-number">2</span> <span class="hljs-string">"Must be greater than 2 characters"</span>
  <span class="hljs-literal">lte</span> <span class="hljs-number">256</span> <span class="hljs-string">"Must be less than or equal to 256 characters"</span>

<span class="hljs-built_in">String</span> bio
  <span class="hljs-literal">lte</span> <span class="hljs-number">140</span> <span class="hljs-string">"A bio must fit into a tweet"</span>

<span class="hljs-built_in">Boolean</span> accountType
</code></pre>
<p>Visit the project on <a href="https://github.com/voltraco/dml">Github</a>.</p>

    </div>
  </div>


  <div class="post" id="Photo-Sharing">
    <a class="link" href="#Photo-Sharing">
      <div class="labels"><span>Photography</span></div>
      <h1 class="title">Photo Sharing</h1>
    </a>
    <div class="body">
      <p><img src="https://cloud.githubusercontent.com/assets/136109/20639024/7fa69cb6-b3b8-11e6-89b1-18c740850652.png" alt="image"></p>
<p>Instagram has a cool hidden feature that will render your photo as ascii art. If you inspect the url of an image and add <code>.html</code> or <code>.txt</code> to the filename you get something like what you&#39;re seeing in this picture.</p>

    </div>
  </div>


  <div class="post" id="Amsterdam">
    <a class="link" href="#Amsterdam">
      <div class="labels"><span>Travel</span></div>
      <h1 class="title">Amsterdam</h1>
    </a>
    <div class="body">
      <h1 id="if-you-are-in-amsterdam-">If you are in Amsterdam...</h1>
<p><img src="https://cloud.githubusercontent.com/assets/136109/17458765/b0bf36ca-5beb-11e6-9a3f-65976ddfc7fb.png" alt="image"></p>
<p>I&#39;m living in the city. So if you are in town, message me on <a href="https://twitter.com/0x00a">twitter</a> or comment <a href="https://github.com/0x00A/blog/issues/9">here</a> on github. Let&#39;s ride bikes, write code or play music!</p>

    </div>
  </div>


  <div class="post" id="Github-is-a-CMS">
    <a class="link" href="#Github-is-a-CMS">
      <div class="labels"><span>idea</span></div>
      <h1 class="title">Github is a CMS</h1>
    </a>
    <div class="body">
      <p>Github is basically a big content management system. So, here is an attempt to leverage it as a writing and publishing platform! Issues allow any number of authorized users to publish to the same page, hello painless collaborative blogging!</p>
<p><a href="https://github.com/0x00A/blog">This project</a>, the blog you are reading, was co-designed and co-developed by @aprileelcich and myself. If you like it, it&#39;s MIT licensed, so fork it if you want to! There are only a few things you need to do in order to get it working for yourself...</p>
<ul>
<li>Change the <a href="https://github.com/0x00A/blog/blob/gh-pages/CNAME"><code>CNAME</code></a> file to include the correct domain (and obviously your DNS settings to add a CNAME record).</li>
<li>Change the <a href="https://github.com/0x00A/blog/blob/gh-pages/config.json"><code>config.json</code></a> file to reflect the correct username and repository. Also make sure you add yourself to the authors array!</li>
<li>Edit the static HTML, some of this is specific to me and you will want to change that.</li>
</ul>
<p>Happy writing and if you have any questions feel free to ask them on <a href="https://twitter.com/0x00a">twitter</a> or here in the comments section. Ciao. &primes;</p>

    </div>
  </div>


  <div class="post" id="Asynchronous-flow-control-using-generators-and-destructuring">
    <a class="link" href="#Asynchronous-flow-control-using-generators-and-destructuring">
      <div class="labels"><span>idea</span> <span>Programming</span></div>
      <h1 class="title">Asynchronous flow control using generators and destructuring</h1>
    </a>
    <div class="body">
      <p>Two of my favorite things to come out of <a href="">es6</a> were <code>destructuring</code>, an expression that makes it possible to extract data from arrays or objects into distinct variables <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment"><code>1</code></a> and <code>generators</code>, functions which can be exited and later re-entered <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*"><code>2</code></a>. Together these two features can flatten asynchronous flow control.</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> { run, wrap } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'yl'</span>)
<span class="hljs-keyword">const</span> fs = wrap(<span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>))
<span class="hljs-keyword">const</span> assert = <span class="hljs-built_in">require</span>(<span class="hljs-string">'assert'</span>)

run(<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>) </span>{

  <span class="hljs-keyword">const</span> [statError, s] = <span class="hljs-keyword">yield</span> fs.stat(<span class="hljs-string">'./index.js'</span>)
  <span class="hljs-keyword">const</span> [readError, f] = <span class="hljs-keyword">yield</span> fs.readFile(<span class="hljs-string">'./index.js'</span>)

  assert.equal(f.length, s.size)
})
</code></pre>
<p>The above code uses a tiny library called <a href="https://github.com/0x00A/yl">yl</a>. You could write this yourself easily in under 15 lines of code. If you can make it smaller, send me a pull request! The really nice thing about this code is that you can use it <em>today</em> without the need for a massive tool chain or huge compiler like <a href="https://babeljs.io/">babel</a>.</p>
<p>You already know about <a href="http://callbackhell.com/">calback hell</a>. But for context, here is the <code>es5</code> version.</p>
<pre><code class="lang-js"><span class="hljs-selector-tag">var</span> yl = require(<span class="hljs-string">'yl'</span>)
<span class="hljs-selector-tag">var</span> run = yl<span class="hljs-selector-class">.run</span>
<span class="hljs-selector-tag">var</span> wrap = yl<span class="hljs-selector-class">.wrap</span>
<span class="hljs-selector-tag">var</span> fs = wrap(require(<span class="hljs-string">'fs'</span>))
<span class="hljs-selector-tag">var</span> assert = require(<span class="hljs-string">'assert'</span>)

fs.stat(<span class="hljs-string">'./index.js'</span>, function (statError, s) {
  fs.readFile(<span class="hljs-string">'./index.js'</span>, function (readError, f) {
    assert.equal(f<span class="hljs-selector-class">.length</span>, s.size)
  })
})
</code></pre>

    </div>
  </div>

      </section>

    </div>

    <script src="./index.js"></script>

  </body>
</html>
